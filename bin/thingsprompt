#!/home/joente/miniconda3/bin/python
'''ThingsPrompt

Shell client for ThingsDB
'''
import os
import sys
import argparse
import asyncio
import getpass
import re
import json
from setproctitle import setproctitle
from prompt_toolkit.eventloop.defaults import use_asyncio_event_loop
from prompt_toolkit.filters import Condition
from prompt_toolkit.history import FileHistory
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.patch_stdout import patch_stdout
from prompt_toolkit.shortcuts import PromptSession
from thingsdb.client import Client
from thingsdb.exceptions import ThingsDBError


USE_FUN = re.compile(r'^\s*use\s+([\'"0-9a-zA-Z_]+)\s*;?\s*$')
SCOPE_FUN = re.compile(r'^\s*scope\s+(thingsdb|node|\S*)\s*;?\s*$')
DEEP_FUN = re.compile(r'^\s*deep\s+([0-9]+)\s*;?\s*$')
ALL_FUN = re.compile(r'^\s*all\s+(true|false)\s*;?\s*$')
TAB = ' ' * 4
HELP = '''
Special commands:

?
    This help.
use <collection>
    Switch to a collection (id or name)
scope <thingsdb|node>
    Switch to `thingsdb` or `node` scope
deep <level>
    Return statements using a specified level, for example deep 2
all <bool>
    When `true`, all statement results are returned, if `false` only the last.
*empty line
    Enable multiline query. A new empty line will send the query.
'''

bindings = KeyBindings()
session = None


@Condition
def is_active():
    return session.multiline


def on_enter(event):
    last_enter_idx = event.app.current_buffer.text.rfind('\n')
    last_line = event.app.current_buffer.text[last_enter_idx+1:].rstrip()

    if last_line:
        for idx, c in enumerate(last_line):
            if not c.isspace():
                break

        indent = last_line[:idx]

        if last_line and last_line[-1] in ('{', '(', '['):
            indent += TAB

        event.app.current_buffer.insert_text('\n' + indent)
    else:
        session.multiline = False
        set_prompt(session.client, session)
        event.app.current_buffer.validate_and_handle()


@bindings.add('tab')
def _(event):
    """Insert TAB"""
    event.app.current_buffer.insert_text(TAB)


@bindings.add('escape', 'enter', filter=is_active)
def _(event):
    event.current_buffer.insert_text('\n')


@bindings.add('enter', filter=is_active)
def _(event):
    on_enter(event)


@bindings.add('backspace', filter=is_active)
def _(event):
    buffer = event.app.current_buffer
    text = buffer.text[:buffer.cursor_position]
    indent = len(text) - len(text.rstrip(' '))
    if indent and indent % 4 == 0:
        for _ in range(4):
            buffer.delete_before_cursor()
    else:
        buffer.delete_before_cursor()


async def connect(client, args):
    await client.connect(args.node, args.port, timeout=args.timeout)
    await client.authenticate(args.user, args.password, timeout=args.timeout)


def set_prompt(client, session):
    target = client.get_target().name()
    title = f'{client._username}@{client.connection_info()} ({target})'
    print(f'\33]0;{title}\a', end='', flush=True)
    session.message = f'{title}> '


def set_multi_input_prompt(session):
    session.message = ''


def set_target(client, target):
    try:
        target = int(target)
    except ValueError:
        target = target.strip('\'"')

    client.use(target)


def check_deep(deep):
    if args.deep < 0 or args.deep > 127:
        print(f'argument `deep` should be between 0 and 127, got {args.deep}')
        return False
    return True


def set_deep(args, deep):
    if check_deep(deep):
        args.deep = deep
        print(f'set `depth` level to {args.deep}')


async def prompt_loop(client, args):
    global session
    try:
        history_file = os.path.join(
            os.path.expanduser('~'),
            '.thingsprompt.history'
        )
        history = FileHistory(history_file)
    except Exception as e:
        history = InMemoryHistory()

    if args.collection:
        set_target(client, args.collection)

    session = PromptSession(history=history)
    session.client = client

    set_prompt(client, session)

    while True:
        try:
            query = await session.prompt(async_=True, key_bindings=bindings)

            if query.strip() == '?':
                print(HELP)
                continue

            if query == '':
                session.multiline = True
                set_multi_input_prompt(session)
                continue

            use = USE_FUN.match(query)
            if use:
                target = use.group(1)
                try:
                    target = int(target)
                except ValueError:
                    target = target.strip('\'"')

                client.use(target)
                set_prompt(client, session)
                continue

            scope = SCOPE_FUN.match(query)
            if scope:
                target = scope.group(1)
                if target == 'node':
                    target = client.node
                elif target == 'thingsdb':
                    target = client.thingsdb
                else:
                    print(
                        'invalid scope; should be either `thingsdb` or `node`')
                    continue
                client.use(target)
                set_prompt(client, session)
                continue

            deep = DEEP_FUN.match(query)
            if deep:
                set_deep(args, int(deep.group(1)))
                continue

            retall = ALL_FUN.match(query)
            if retall:
                args.all = retall.group(1) == 'true'
                continue

            if not client.is_connected():
                print('not connected')
                continue

            try:
                res = await client.query(
                    query,
                    deep=args.deep,
                    all_=args.all,
                    timeout=args.timeout)
            except ThingsDBError as e:
                print(f'{e.__class__.__name__}: {e}')
            else:
                print(json.dumps(res, sort_keys=True, indent=4))

        except (EOFError, KeyboardInterrupt):
            return

if __name__ == '__main__':
    setproctitle('thingsprompt')
    use_asyncio_event_loop()

    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--node', '-n',
        type=str,
        default='localhost',
        help='node address')

    parser.add_argument(
        '--port',
        type=int,
        default=9200,
        help='TCP port where the node is listening on for API calls')

    parser.add_argument(
        '--user', '-u',
        type=str,
        required=True,
        help='user name')

    parser.add_argument(
        '--password', '-p',
        type=str,
        help='password, will be prompted if not given')

    parser.add_argument(
        '--deep',
        type=int,
        default=1,
        help='specify to which depth `things` should be fully fetched')

    parser.add_argument(
        '--all', '-a',
        action='store_true',
        help='return all statement results instead of just the last one')

    parser.add_argument(
        '--scope', '-s',
        choices=['thingsdb', 'node', 'collection'],
        default='thingsdb',
        help=(
            'set the initial scope; '
            'if the scope is set to `collection`, then the `--collection` '
            'argument is required; '
            'the collection/scope can be changed within the prompt by using '
            'the command: `use ...`'
        ))

    parser.add_argument(
        '--collection', '-c',
        type=str,
        help=(
            'name of the collection to use; '
            'the collection/scope can be changed within the prompt by using '
            'the command: `use ...`'
        ))

    parser.add_argument(
        '--timeout',
        type=int,
        help='connect and query timeout in seconds')

    args = parser.parse_args()

    if args.password is None:
        args.password = getpass.getpass('password: ')

    if args.collection is None and args.scope == 'collection':
        sys.exit(
            'scope `collection` is used; '
            'a collection is required, see `--collection`')

    if args.collection is not None:
        args.scope = 'collection'

    if not check_deep(args.deep):
        exit(1)

    client = Client()
    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(connect(client, args))
    except Exception as e:
        print(f'{e.__class__.__name__}: {e}', file=sys.stderr)
        exit(1)

    with patch_stdout():
        loop.run_until_complete(prompt_loop(client, args))

    client.close()
    loop.run_until_complete(client.wait_closed())
