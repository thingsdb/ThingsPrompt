#!/usr/bin/env python
'''ThingsPrompt

Shell client for ThingsDB
'''
import os
import sys
import argparse
import asyncio
import getpass
import re
import json
from setproctitle import setproctitle
from prompt_toolkit.eventloop.defaults import use_asyncio_event_loop
from prompt_toolkit.filters import Condition
from prompt_toolkit.history import FileHistory
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.patch_stdout import patch_stdout
from prompt_toolkit.shortcuts import PromptSession
from thingsdb.client import Client
from thingsdb.exceptions import ThingsDBError
from thingsdb.client.scope import (
    node as node_scope,
    thingsdb as thingsdb_scope
)


USE_FUN = re.compile(r'^\s*u(se)?\s+([\'"0-9a-zA-Z_]+)\s*;?\s*$')
SCOPE_FUN = re.compile(r'^\s*s(cope)?\s+(thingsdb|node|\S*)\s*;?\s*$')
DEEP_FUN = re.compile(r'^\s*d(eep)?\s+([0-9]+)\s*;?\s*$')
NODE_SCOPE = re.compile(r'^\s*n(ode)?:\s+(.*)$')
THINGSDB_SCOPE = re.compile(r'^\s*t(hingsdb)?:\s+(.*)$')
TAB = ' ' * 4
HELP = '''
Special commands:

?
    This help.
u/use <collection>
    Switch to a collection (id or name)
s/scope <thingsdb|node>
    Switch to `thingsdb` or `node` scope
n/node <query>
    Set node scope with a single query
t/thingsdb <query>
    Set thingsdb scope with a singel query
d/deep <level>
    Return statements using a specified level, for example deep 2
*empty line
    Enable multiline query. A new empty line will send the query.
'''

bindings = KeyBindings()
session = None


@Condition
def is_active():
    return session.multiline


def on_enter(event):
    last_enter_idx = event.app.current_buffer.text.rfind('\n')
    last_line = event.app.current_buffer.text[last_enter_idx+1:].rstrip()

    if last_line:
        for idx, c in enumerate(last_line):
            if not c.isspace():
                break

        indent = last_line[:idx]

        if last_line and last_line[-1] in ('{', '(', '['):
            indent += TAB

        event.app.current_buffer.insert_text('\n' + indent)
    else:
        if not event.app.current_buffer.text.strip():
            event.app.current_buffer.insert_text('nil;')
        session.multiline = False
        set_prompt(session.client, session)
        event.app.current_buffer.validate_and_handle()


@bindings.add('tab')
def _(event):
    """Insert TAB"""
    event.app.current_buffer.insert_text(TAB)


@bindings.add('escape', 'enter', filter=is_active)
def _(event):
    event.current_buffer.insert_text('\n')


@bindings.add('enter', filter=is_active)
def _(event):
    on_enter(event)


@bindings.add('backspace', filter=is_active)
def _(event):
    buffer = event.app.current_buffer
    text = buffer.text[:buffer.cursor_position]
    indent = len(text) - len(text.rstrip(' '))
    if indent and indent % 4 == 0:
        for _ in range(4):
            buffer.delete_before_cursor()
    else:
        buffer.delete_before_cursor()


async def connect(client, args, auth):
    await client.connect(args.node, args.port, timeout=args.timeout)
    await client.authenticate(auth=auth, timeout=args.timeout)


def set_prompt(client, session):
    scope = client.get_scope_name()
    title = f'{client.connection_info()} ({scope})'
    print(f'\33]0;{title}\a', end='', flush=True)
    session.message = f'{title}> '


def set_multi_input_prompt(session):
    session.message = ''


def set_scope(client, scope):
    try:
        scope = int(scope)
    except ValueError:
        scope = scope.strip('\'"')

    client.use(scope)


def check_deep(deep):
    if args.deep < 0 or args.deep > 127:
        print(f'argument `deep` should be between 0 and 127, got {args.deep}')
        return False
    return True


def set_deep(args, deep):
    if check_deep(deep):
        args.deep = deep
        print(f'set `depth` level to {args.deep}')


async def prompt_loop(client, args):
    global session
    try:
        history_file = os.path.join(
            os.path.expanduser('~'),
            '.thingsprompt.history'
        )
        history = FileHistory(history_file)
    except Exception as e:
        history = InMemoryHistory()

    if args.collection:
        set_scope(client, args.collection)
    elif args.scope == 'node':
        client.use(node_scope)

    session = PromptSession(history=history)
    session.client = client

    set_prompt(client, session)

    while True:
        try:
            query = await session.prompt(async_=True, key_bindings=bindings)

            if query.strip() == '?':
                print(HELP)
                continue

            if query == '':
                if session.multiline is False:
                    session.multiline = True
                    set_multi_input_prompt(session)
                    continue

            use = USE_FUN.match(query)
            if use:
                scope = use.group(2)
                try:
                    scope = int(scope)
                except ValueError:
                    scope = scope.strip('\'"')

                client.use(scope)
                set_prompt(client, session)
                continue

            scope = SCOPE_FUN.match(query)
            if scope:
                scope = scope.group(2)
                if scope == 'node':
                    scope = node_scope
                elif scope == 'thingsdb':
                    scope = thingsdb_scope
                else:
                    print(
                        'invalid scope; should be either `thingsdb` or `node`')
                    continue
                client.use(scope)
                set_prompt(client, session)
                continue

            deep = DEEP_FUN.match(query)
            if deep:
                set_deep(args, int(deep.group(2)))
                continue

            scope = NODE_SCOPE.match(query)
            if scope:
                query = scope.group(2)
                scope = node_scope
            else:
                scope = THINGSDB_SCOPE.match(query)
                if scope:
                    query = scope.group(2)
                    scope = thingsdb_scope
                else:
                    scope = None

            if not client.is_connected():
                print('not connected')
                continue

            try:
                res = await client.query(
                    query,
                    target=scope,
                    deep=args.deep,
                    timeout=args.timeout)
            except ThingsDBError as e:
                print(f'{e.__class__.__name__}: {e}')
            else:
                print(json.dumps(res, sort_keys=True, indent=4))

        except (EOFError, KeyboardInterrupt):
            return

if __name__ == '__main__':
    setproctitle('thingsprompt')
    use_asyncio_event_loop()

    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--node', '-n',
        type=str,
        default='localhost',
        help='node address')

    parser.add_argument(
        '--port',
        type=int,
        default=9200,
        help='TCP port where the node is listening on for API calls')

    parser.add_argument(
        '--user', '-u',
        type=str,
        help='user name')

    parser.add_argument(
        '--password', '-p',
        type=str,
        help='password, will be prompted if not given')

    parser.add_argument(
        '--token', '-t',
        type=str,
        help='token key')

    parser.add_argument(
        '--deep',
        type=int,
        default=1,
        help='specify to which depth `things` should be fully fetched')

    parser.add_argument(
        '--scope', '-s',
        choices=['thingsdb', 'node', 'collection'],
        default='thingsdb',
        help=(
            'set the initial scope; '
            'if the scope is set to `collection`, then the `--collection` '
            'argument is required; '
            'the collection/scope can be changed within the prompt by using '
            'the command: `use ...`'
        ))

    parser.add_argument(
        '--collection', '-c',
        type=str,
        help=(
            'name of the collection to use; '
            'the collection/scope can be changed within the prompt by using '
            'the command: `use ...`'
        ))

    parser.add_argument(
        '--timeout',
        type=int,
        help='connect and query timeout in seconds')

    args = parser.parse_args()

    if args.token is None:
        if args.user is None:
            sys.exit('one of the arguments -t/--token or -u/--user is required')

        if args.password is None:
            args.password = getpass.getpass('password: ')

        auth = [args.user, args.password]
    else:
        if args.user is not None:
            sys.exit('use arguments -t/--token or -u/--user, not both')
        auth = args.token

    if args.collection is None and args.scope == 'collection':
        sys.exit(
            'scope `collection` is used; '
            'a collection is required, see `--collection`')

    if args.collection is not None:
        args.scope = 'collection'

    if not check_deep(args.deep):
        exit(1)

    client = Client()
    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(connect(client, args, auth))
    except Exception as e:
        print(f'{e.__class__.__name__}: {e}', file=sys.stderr)
        exit(1)

    with patch_stdout():
        loop.run_until_complete(prompt_loop(client, args))

    client.close()
    loop.run_until_complete(client.wait_closed())
