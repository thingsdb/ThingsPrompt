#!/home/joente/miniconda3/bin/python3
'''ThingsPrompt

Shell client for ThingsDB
'''
import os
import sys
import argparse
import asyncio
import getpass
import re
import json
from setproctitle import setproctitle
from prompt_toolkit.shortcuts import PromptSession
from prompt_toolkit.eventloop.defaults import use_asyncio_event_loop
from prompt_toolkit.patch_stdout import patch_stdout
from prompt_toolkit.history import FileHistory
from prompt_toolkit.history import InMemoryHistory
from thingsdb.client import Client
from thingsdb.exceptions import ThingsDBError


USE_FUN = re.compile(r'^\s*use\s+([\'"0-9a-zA-Z_]+);?$')
DEEP_FUN = re.compile(r'^\s*deep\s+([0-9]+);?$')
ALL_FUN = re.compile(r'^\s*all\s+(true|false);?$')


async def connect(client, args):
    await client.connect(args.node, args.port, timeout=args.timeout)
    await client.authenticate(args.user, args.password, timeout=args.timeout)


def set_prompt(client, session):
    target = client.get_target()
    target = f' ({target})' if target else ''
    title = f'{client._username}@{client.connection_info()}{target}'
    print(f'\33]0;{title}\a', end='', flush=True)
    session.message = f'{title}> '


def set_target(client, target):
    try:
        target = int(target)
    except ValueError:
        target = target.strip('\'"')

    client.use(target)


def check_deep(deep):
    if args.deep < 0 or args.deep > 127:
        print(f'argument `deep` should be between 0 and 127, got {args.deep}')
        return False
    return True


def set_deep(args, deep):
    if check_deep(deep):
        args.deep = deep
        print(f'set `depth` level to {args.deep}')


async def prompt_loop(client, args):
    try:
        history_file = os.path.join(
            os.path.expanduser('~'),
            '.thingsprompt.history'
        )
        history = FileHistory(history_file)
    except Exception as e:
        history = InMemoryHistory()

    if args.collection:
        set_target(client, args.collection)

    session = PromptSession(history=history)
    set_prompt(client, session)

    while True:
        try:
            query = await session.prompt(async_=True)

            use = USE_FUN.match(query)
            if use:
                target = use.group(1)
                try:
                    target = int(target)
                except ValueError:
                    target = target.strip('\'"')

                client.use(target)
                set_prompt(client, session)
                continue

            deep = DEEP_FUN.match(query)
            if deep:
                set_deep(args, int(deep.group(1)))
                continue

            retall = ALL_FUN.match(query)
            if retall:
                args.all = retall.group(1) == 'true'
                continue

            if not client.is_connected():
                print('not connected')
                continue

            try:
                res = await client.query(
                    query,
                    deep=args.deep,
                    all=args.all,
                    timeout=args.timeout)
            except ThingsDBError as e:
                print(f'{e.__class__.__name__}: {e}')
            else:
                print(json.dumps(res, sort_keys=True, indent=4))

        except (EOFError, KeyboardInterrupt):
            return

if __name__ == '__main__':
    setproctitle('thingsprompt')
    use_asyncio_event_loop()

    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--node', '-n',
        type=str,
        default='localhost',
        help='node address')

    parser.add_argument(
        '--port',
        type=int,
        default=9200,
        help='TCP port where the node is listening on for API calls')

    parser.add_argument(
        '--user', '-u',
        type=str,
        required=True,
        help='user name')

    parser.add_argument(
        '--password', '-p',
        type=str,
        help='password, will be prompted if not given')

    parser.add_argument(
        '--deep',
        type=int,
        default=1,
        help='specify to which depth `things` should be fully fetched')

    parser.add_argument(
        '--all', '-a',
        action='store_true',
        help='return all statement results instead of just the last one')

    parser.add_argument(
        '--collection', '-c',
        type=str,
        help=(
            'name or the collection to use, if not given the root is used;'
            'the collection can be changed within the prompt by using '
            'the command: `use ...`'))

    parser.add_argument(
        '--timeout',
        type=int,
        help='connect and query timeout in seconds')

    args = parser.parse_args()

    if args.password is None:
        args.password = getpass.getpass('password: ')

    if not check_deep(args.deep):
        exit(1)

    client = Client()
    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(connect(client, args))
    except Exception as e:
        print(f'{e.__class__.__name__}: {e}', file=sys.stderr)
        exit(1)

    with patch_stdout():
        loop.run_until_complete(prompt_loop(client, args))

    client.close()
    loop.run_until_complete(client.wait_closed())
