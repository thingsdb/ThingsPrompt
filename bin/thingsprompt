#!/usr/bin/env python
'''ThingsPrompt

Shell client for ThingsDB
'''
import os
import sys
import argparse
import asyncio
import getpass
import re
import json
from setproctitle import setproctitle
from prompt_toolkit.eventloop.defaults import use_asyncio_event_loop
from prompt_toolkit.filters import Condition
from prompt_toolkit.history import FileHistory
from prompt_toolkit.history import InMemoryHistory
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.patch_stdout import patch_stdout
from prompt_toolkit.shortcuts import PromptSession
from thingsdb.client import Client
from thingsdb.exceptions import ThingsDBError


USE_FUN = re.compile(r'^\s*(@[\:0-9a-zA-Z_]+)\s*$')
SCOPE_QUERY = re.compile(r'^\s*(@[\:0-9a-zA-Z_]+)\s+(.*)$')

TAB = ' ' * 4
HELP = '''
Special commands:

?
    This help.
<@scope>
    Switch to another scope
<@scope> <query>
    Run a single query in a given scope
CTRL + n
    Insert a new line
'''

bindings = KeyBindings()
session = None


@Condition
def is_active():
    return session.multiline


def on_enter_new_line(event):
    last_enter_idx = event.app.current_buffer.text.rfind('\n')
    last_line = event.app.current_buffer.text[last_enter_idx+1:].rstrip()

    idx = 0
    for idx, c in enumerate(last_line):
        if not c.isspace():
            break

    indent = last_line[:idx]

    if last_line and last_line[-1] in ('{', '(', '['):
        indent += TAB

    event.app.current_buffer.insert_text('\n' + indent)

    # if not event.app.current_buffer.text.strip():
    #     event.app.current_buffer.insert_text('nil;')
    # session.multiline = False
    # set_prompt(session.client, session)
    # event.app.current_buffer.validate_and_handle()


@bindings.add('tab')
def _(event):
    """Insert TAB"""
    event.app.current_buffer.insert_text(TAB)


@bindings.add('c-n')
def _(event):
    on_enter_new_line(event)


@bindings.add('backspace')
def _(event):
    buffer = event.app.current_buffer
    text = buffer.text[:buffer.cursor_position]
    indent = len(text) - len(text.rstrip(' '))
    if indent and indent % 4 == 0:
        for _ in range(4):
            buffer.delete_before_cursor()
    else:
        buffer.delete_before_cursor()


async def connect(client, args, auth):
    await client.connect(args.node, args.port, timeout=args.timeout)
    await client.authenticate(*auth, timeout=args.timeout)


def set_prompt(client, session):
    scope = client.get_scope()
    title = f'{client.connection_info()} ({scope})'
    print(f'\33]0;{title}\a', end='', flush=True)
    session.message = f'{title}> '


# def set_multi_input_prompt(session):
#     session.message = ''


def set_scope(client, scope):
    try:
        scope = int(scope)
    except ValueError:
        scope = scope.strip('\'"')

    client.use(scope)


async def prompt_loop(client, args):
    global session
    try:
        history_file = os.path.join(
            os.path.expanduser('~'),
            '.thingsprompt.history'
        )
        history = FileHistory(history_file)
    except Exception as e:
        history = InMemoryHistory()

    session = PromptSession(history=history)
    session.client = client

    set_prompt(client, session)

    while True:
        try:
            query = await session.prompt(async_=True, key_bindings=bindings)

            if query.strip() == '?':
                print(HELP)
                continue

            use = USE_FUN.match(query)
            if use:
                scope = use.group(1)
                try:
                    scope = int(scope)
                except ValueError:
                    scope = scope.strip('\'"')

                client.use(scope)
                set_prompt(client, session)
                continue

            scope = SCOPE_QUERY.match(query)
            if scope:
                query = scope.group(2)
                scope = scope.group(1)
            else:
                scope = None

            if not client.is_connected():
                print('not connected')
                continue

            try:
                res = await client.query(
                    query,
                    scope=scope,
                    timeout=args.timeout)
            except ThingsDBError as e:
                print(f'{e.__class__.__name__}: {e}')
            else:
                print(json.dumps(res, sort_keys=True, indent=4))

        except (EOFError, KeyboardInterrupt):
            return

if __name__ == '__main__':
    setproctitle('thingsprompt')
    use_asyncio_event_loop()

    parser = argparse.ArgumentParser()

    parser.add_argument(
        '--node', '-n',
        type=str,
        default='localhost',
        help='node address')

    parser.add_argument(
        '--port',
        type=int,
        default=9200,
        help='TCP port where the node is listening on for API calls')

    parser.add_argument(
        '--user', '-u',
        type=str,
        help='user name')

    parser.add_argument(
        '--password', '-p',
        type=str,
        help='password, will be prompted if not given')

    parser.add_argument(
        '--token', '-t',
        type=str,
        help='token key')

    parser.add_argument(
        '--scope', '-s',
        type=str,
        default='@thingsdb',
        help='set the initial scope')

    parser.add_argument(
        '--timeout',
        type=int,
        help='connect and query timeout in seconds')

    args = parser.parse_args()

    if args.token is None:
        if args.user is None:
            sys.exit(
                'one of the arguments -t/--token or -u/--user is required')

        if args.password is None:
            args.password = getpass.getpass('password: ')

        auth = [args.user, args.password]
    else:
        if args.user is not None:
            sys.exit('use arguments -t/--token or -u/--user, not both')
        auth = args.token

    client = Client()
    client.use(args.scope)
    loop = asyncio.get_event_loop()

    try:
        loop.run_until_complete(connect(client, args, auth))
    except Exception as e:
        print(f'{e.__class__.__name__}: {e}', file=sys.stderr)
        exit(1)

    with patch_stdout():
        loop.run_until_complete(prompt_loop(client, args))

    client.close()
    loop.run_until_complete(client.wait_closed())
